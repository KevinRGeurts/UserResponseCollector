This file contains developer documentation for the UserResponseCollector. This project origniated within the BlackJackSim project.
Here it is being separated as its own project and significantly refactored. The intent is to refactor it using the Command design
pattern, to eliminate the enumeration of query types, and to enable extensibility for individual applications by creating new
child command classes.

Following terminology in the Command section of the Gang of Four design patterns book:
1. UserQueryReceiver (abstract base class) = The object that knows how to perform the operations associated with carrying out a request.
	a. A Child version (UserQueryConsoleReceiver) will be a class that knows how to use python input and print statements to interact with the user
		in a command prompt window.
	b. Another child version (UserQueryTkinterReceiver) will know how to interact with the user of a tkinter based GUI application.
	c. Question: Should we have an abstract Receiver base class and then two child class implementations, one for command window, one for tkinter?
2. Invoker = The oject that asks the Command to carry out the request.
	a. Think that this will be the Client. The Client will instantiate a Command object, assign it the correct Receiver, and call its Execute method.
3. Client = Create a ConcreteCommand object and set its Receiver.
	a. This will be for example the black jack or cribbage simulator.
4 UserQueryCommand = Abstract base class that delcares an interface for exeuting an operation.
5. UserQuerryCommandX = Implements the Command interface, by invoking methods in its Receiver
	a. X = Menu, NumberInteger (really an integer), Cards (define/implement within BlackJackSim), PathSave, PathOpen,
		MusicalPitch (define/implement within GuitarTab)...

Current issues:
1. UserQueryReceiver is implemented using Global Object Pattern and Prebound Method Pattern, which is not really compatible with the UserQueryCommand
	having a receiver. Coding around this for now, but need to decide how to handle this. While retaining the ability for simulator code not to care
	if the receiver is a console or a tkinter app. Can I pass the global object in as the receiver? Can I pass the two prebound methods in to the command
	as callables rather than passing in the receiver (not very OO)? Do I need a factory to create commands with the right type of receiver?
		a. Possible Soloution 1: How about have a prebound method that takes a UserQueryCommand object as an argument and assigns it the correct 
			receiver? In other words, the Client would set the receiver of the command object by passing the command object to the prebound method.
			Currently the command's __init__ takes the receiver object as an argument, so maybe have a prebound method that returns the receiver,
			so that the return value of the prebound method can be included in the argument list when the command object is constructed. This soluiton
			would retain the prebound method pattern as the way to "swap" from console to tkinterapp for the receiver, without simulator code having
			to change.
	NOTE: This issue was resolved by providing a method of UserQueryReceiver that returns self, and then providing a prebound method to this method.
	When a Client constructs a Command object, it calls the prebound method to get the global object UserQueryReceiver and passes it in the Command's
	constructor (__init__()).
2. Not quite sure how PathSave and PathOpen commands are going to generalize between console (enter a string) and tkinter app using file dialogs.